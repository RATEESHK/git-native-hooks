# ==============================================================================
# Git Hooks Custom Commands Configuration
# ==============================================================================
# This file defines custom commands to be executed during Git hook execution.
# Commands are executed based on priority, with support for timeouts, 
# mandatory/optional execution, and parallel processing.
#
# Format: HOOK:PRIORITY:MANDATORY:TIMEOUT:COMMAND:DESCRIPTION
#
# Fields:
#   HOOK        - Hook name (pre-commit, pre-push, commit-msg, etc.)
#   PRIORITY    - Execution order (lower number = higher priority, runs first)
#   MANDATORY   - true/false - whether failure blocks the entire hook
#   TIMEOUT     - Maximum execution time in seconds (command killed after)
#   COMMAND     - Shell command to execute (can use variables like {staged})
#   DESCRIPTION - Human-readable description shown during execution
#
# Variables:
#   {staged}    - Expands to space-separated list of staged files (pre-commit only)
#                 Example: "src/file1.js src/file2.ts"
#
# Tips:
#   - Commands with same priority run in order (or parallel if enabled)
#   - Use mandatory=false for optional quality checks
#   - Set appropriate timeouts to prevent hanging
#   - Test commands work in isolation before adding
#   - Use specific file patterns with {staged} for efficiency
#
# ==============================================================================

# ==============================================================================
# JavaScript/TypeScript Project Examples
# ==============================================================================

# Format checking with Prettier
# pre-commit:1:true:30:npx prettier --check {staged}:Prettier Format Check

# Linting with ESLint
# pre-commit:2:true:60:npx eslint {staged}:ESLint

# TypeScript type checking (optional - can be slow)
# pre-commit:3:false:120:npx tsc --noEmit --skipLibCheck:TypeScript Check

# Auto-fix linting issues (alternative to check-only)
# pre-commit:2:true:60:npx eslint --fix {staged}:ESLint Auto-fix

# Lint-staged (automatically configured if .lintstagedrc exists)
# pre-commit:1:true:60:npx lint-staged:Lint-Staged

# Unit tests before push
# pre-push:1:true:300:npm test:Run Unit Tests

# Integration tests (optional - can be slow)
# pre-push:2:false:600:npm run test:integration:Run Integration Tests

# Build verification before push
# pre-push:3:false:600:npm run build:Build Project

# ==============================================================================
# Python Project Examples
# ==============================================================================

# Format checking with Black
# pre-commit:1:true:30:black --check {staged}:Black Format Check

# Linting with Flake8
# pre-commit:2:true:60:flake8 {staged}:Flake8 Linting

# Type checking with MyPy (optional)
# pre-commit:3:false:60:mypy {staged}:MyPy Type Check

# Security check with Bandit
# pre-commit:4:false:30:bandit -r {staged}:Security Check

# Import sorting check
# pre-commit:5:true:20:isort --check {staged}:Import Sort Check

# Unit tests
# pre-push:1:true:300:pytest tests/unit:Run Unit Tests

# Integration tests (optional)
# pre-push:2:false:600:pytest tests/integration:Run Integration Tests

# Coverage report (optional)
# pre-push:3:false:180:pytest --cov=src --cov-report=term:Coverage Report

# ==============================================================================
# Go Project Examples
# ==============================================================================

# Format checking
# pre-commit:1:true:30:test -z $(gofmt -l {staged}):Go Format Check

# Vetting
# pre-commit:2:true:60:go vet ./...:Go Vet

# Linting with golangci-lint
# pre-commit:3:true:90:golangci-lint run {staged}:GolangCI-Lint

# Unit tests
# pre-push:1:true:300:go test ./...:Run Tests

# Build verification
# pre-push:2:false:180:go build ./...:Build Project

# Race condition detection (optional)
# pre-push:3:false:300:go test -race ./...:Race Detection

# ==============================================================================
# Rust Project Examples
# ==============================================================================

# Format checking
# pre-commit:1:true:30:cargo fmt -- --check:Cargo Format Check

# Linting with Clippy
# pre-commit:2:true:90:cargo clippy -- -D warnings:Clippy Linting

# Unit tests
# pre-push:1:true:300:cargo test:Run Tests

# Build verification
# pre-push:2:false:600:cargo build --release:Release Build

# ==============================================================================
# Java/Maven Project Examples
# ==============================================================================

# Format checking with Spotless
# pre-commit:1:true:60:mvn spotless:check:Spotless Format Check

# Compilation check
# pre-commit:2:true:120:mvn compile:Compile Check

# Unit tests
# pre-push:1:true:300:mvn test:Run Unit Tests

# Integration tests (optional)
# pre-push:2:false:600:mvn verify:Run Integration Tests

# Package build (optional)
# pre-push:3:false:600:mvn package -DskipTests:Build Package

# ==============================================================================
# Docker/Infrastructure Examples
# ==============================================================================

# Dockerfile linting
# pre-commit:1:true:30:docker run --rm -i hadolint/hadolint < Dockerfile:Hadolint

# Terraform formatting
# pre-commit:1:true:30:terraform fmt -check -recursive:Terraform Format

# Terraform validation
# pre-commit:2:true:60:terraform validate:Terraform Validate

# YAML linting
# pre-commit:3:true:30:yamllint {staged}:YAML Lint

# Kubernetes manifest validation
# pre-commit:4:false:60:kubectl apply --dry-run=client -f {staged}:K8s Validation

# ==============================================================================
# Security & Quality Checks Examples
# ==============================================================================

# Secret scanning
# pre-commit:1:true:60:gitleaks protect --staged:Secret Scanning

# Dependency vulnerability check
# pre-push:1:false:120:npm audit --production:Dependency Audit

# License compliance check
# pre-push:2:false:60:license-checker:License Check

# Code complexity check
# pre-commit:3:false:90:complexity {staged}:Complexity Check

# ==============================================================================
# Multi-language/Universal Examples
# ==============================================================================

# Spell checking in documentation
# pre-commit:1:false:30:cspell {staged}:Spell Check

# Markdown linting
# pre-commit:2:false:30:markdownlint {staged}:Markdown Lint

# Git conflict markers check
# pre-commit:1:true:10:! grep -r "<<<<<<< HEAD" {staged}:Conflict Markers Check

# TODO/FIXME check (warning only)
# pre-commit:5:false:10:! grep -r "TODO\|FIXME" {staged}:TODO/FIXME Check

# File size check (prevent large files)
# pre-commit:1:true:10:test $(find {staged} -size +10M | wc -l) -eq 0:Large File Check

# ==============================================================================
# Example: Comprehensive JavaScript/TypeScript Setup
# ==============================================================================
# Uncomment the section below for a complete JS/TS workflow

# Stage 1: Fast formatting and basic checks (< 1 minute)
# pre-commit:1:true:30:npx prettier --check {staged}:Format Check
# pre-commit:2:true:60:npx eslint {staged}:Linting

# Stage 2: Type checking (optional, can be slow)
# pre-commit:3:false:120:npx tsc --noEmit --skipLibCheck:Type Check

# Stage 3: Unit tests before push (< 5 minutes)
# pre-push:1:true:300:npm test -- --passWithNoTests:Unit Tests

# Stage 4: Build verification (optional, slower)
# pre-push:2:false:600:npm run build:Build Verification

# ==============================================================================
# Example: Comprehensive Python Setup
# ==============================================================================
# Uncomment the section below for a complete Python workflow

# Stage 1: Fast formatting and linting (< 1 minute)
# pre-commit:1:true:30:black --check {staged}:Black Format
# pre-commit:2:true:60:flake8 {staged}:Flake8
# pre-commit:3:true:30:isort --check {staged}:Import Sort

# Stage 2: Type and security checks (optional)
# pre-commit:4:false:60:mypy {staged}:Type Check
# pre-commit:5:false:30:bandit -r {staged}:Security Scan

# Stage 3: Unit tests before push
# pre-push:1:true:300:pytest tests/unit -v:Unit Tests

# Stage 4: Coverage and integration tests (optional)
# pre-push:2:false:600:pytest tests/integration -v:Integration Tests
# pre-push:3:false:180:pytest --cov=src --cov-report=term:Coverage

# ==============================================================================
# Custom Project Commands
# ==============================================================================
# Add your project-specific commands below

# Example: Custom validation script
# pre-commit:1:true:30:./scripts/validate-code.sh {staged}:Custom Validation

# Example: Database migration check
# pre-push:1:true:60:./scripts/check-migrations.sh:Migration Check

# Example: API contract validation
# pre-push:2:false:90:./scripts/validate-api-contracts.sh:API Contract Check

# Example: Performance benchmarks
# pre-push:3:false:300:npm run benchmark:Performance Benchmarks

# ==============================================================================
# LOCKFILE MANAGEMENT & VALIDATION
# ==============================================================================
# Lockfiles ensure reproducible builds across environments. These commands
# validate lockfile integrity, detect sync issues, and prevent common problems.
#
# Why Lockfile Validation Matters:
#   • Prevents "works on my machine" issues
#   • Ensures reproducible CI/CD builds
#   • Catches dependency conflicts early
#   • Prevents merge conflict corruption
#   • Maintains supply chain security
#
# Recommendations:
#   • Start with mandatory=false (warnings only) for 1-2 weeks
#   • Monitor team adoption and issues
#   • Switch to mandatory=true after team is comfortable
#   • Keep checks fast (<30s) to avoid workflow disruption
#
# Note: post-commit hook already provides helpful hints when lockfiles change.
#       These commands provide pre-commit/pre-push validation.
# ==============================================================================

# ------------------------------------------------------------------------------
# Node.js / JavaScript / TypeScript Projects
# ------------------------------------------------------------------------------

# Check if package.json changed without corresponding lockfile update
# This catches the common mistake of updating dependencies without regenerating lockfile
# pre-commit:1:false:10:if git diff --cached --name-only | grep -q "^package\.json$"; then if [ -f package-lock.json ] && ! git diff --cached --name-only | grep -q "^package-lock\.json$"; then echo ""; echo "⚠️  package.json modified but package-lock.json not updated!"; echo ""; echo "Fix: Run 'npm install' to regenerate package-lock.json"; echo "Then: git add package-lock.json"; echo ""; exit 1; elif [ -f yarn.lock ] && ! git diff --cached --name-only | grep -q "^yarn\.lock$"; then echo ""; echo "⚠️  package.json modified but yarn.lock not updated!"; echo ""; echo "Fix: Run 'yarn install' to regenerate yarn.lock"; echo "Then: git add yarn.lock"; echo ""; exit 1; elif [ -f pnpm-lock.yaml ] && ! git diff --cached --name-only | grep -q "^pnpm-lock\.yaml$"; then echo ""; echo "⚠️  package.json modified but pnpm-lock.yaml not updated!"; echo ""; echo "Fix: Run 'pnpm install' to regenerate pnpm-lock.yaml"; echo "Then: git add pnpm-lock.yaml"; echo ""; exit 1; fi; fi:Check package.json sync

# Validate npm package-lock.json integrity
# Ensures the lockfile is valid and matches package.json
# pre-commit:2:false:30:if [ -f package-lock.json ] && git diff --cached --name-only | grep -q "^package-lock\.json$"; then if ! npm ls --package-lock-only >/dev/null 2>&1; then echo ""; echo "❌ package-lock.json validation failed!"; echo ""; echo "Common causes:"; echo "  • package-lock.json is corrupted"; echo "  • Versions in package.json don't match lockfile"; echo "  • Manual edit to lockfile (don't do this!)"; echo ""; echo "Fix: Delete and regenerate:"; echo "  rm package-lock.json"; echo "  npm install"; echo "  git add package-lock.json"; echo ""; exit 1; fi; fi:Validate package-lock.json

# Validate Yarn lockfile integrity
# pre-commit:2:false:30:if [ -f yarn.lock ] && git diff --cached --name-only | grep -q "^yarn\.lock$"; then if ! yarn check --integrity --silent 2>/dev/null; then echo ""; echo "❌ yarn.lock validation failed!"; echo ""; echo "Common causes:"; echo "  • yarn.lock is corrupted"; echo "  • Merge conflict markers present"; echo "  • Mismatched yarn versions"; echo ""; echo "Fix: Regenerate lockfile:"; echo "  rm yarn.lock"; echo "  yarn install"; echo "  git add yarn.lock"; echo ""; exit 1; fi; fi:Validate yarn.lock

# Validate pnpm lockfile integrity
# pre-commit:2:false:30:if [ -f pnpm-lock.yaml ] && git diff --cached --name-only | grep -q "^pnpm-lock\.yaml$"; then if ! pnpm install --frozen-lockfile --dry-run >/dev/null 2>&1; then echo ""; echo "❌ pnpm-lock.yaml validation failed!"; echo ""; echo "Common causes:"; echo "  • pnpm-lock.yaml is out of sync"; echo "  • Package versions don't match"; echo "  • Corrupted lockfile"; echo ""; echo "Fix: Regenerate lockfile:"; echo "  rm pnpm-lock.yaml"; echo "  pnpm install"; echo "  git add pnpm-lock.yaml"; echo ""; exit 1; fi; fi:Validate pnpm-lock.yaml

# Detect merge conflict markers in Node.js lockfiles
# Prevents committing corrupted lockfiles after merge conflicts
# pre-commit:1:true:5:if git diff --cached --name-only | grep -qE "package-lock\.json|yarn\.lock|pnpm-lock\.yaml"; then if git diff --cached | grep -qE "^(<{7}|={7}|>{7})"; then echo ""; echo "❌ MERGE CONFLICT markers detected in lockfile!"; echo ""; echo "DO NOT manually resolve lockfile conflicts!"; echo ""; echo "Fix for npm:"; echo "  git checkout --theirs package-lock.json  # or --ours"; echo "  npm install"; echo "  git add package-lock.json"; echo ""; echo "Fix for yarn:"; echo "  git checkout --theirs yarn.lock  # or --ours"; echo "  yarn install"; echo "  git add yarn.lock"; echo ""; echo "Fix for pnpm:"; echo "  git checkout --theirs pnpm-lock.yaml  # or --ours"; echo "  pnpm install"; echo "  git add pnpm-lock.yaml"; echo ""; exit 1; fi; fi:Check Node.js lockfile conflicts

# Warn if lockfile changes but package.json doesn't (unusual but can be valid)
# pre-commit:3:false:10:if git diff --cached --name-only | grep -qE "package-lock\.json|yarn\.lock|pnpm-lock\.yaml"; then if ! git diff --cached --name-only | grep -q "^package\.json$"; then echo ""; echo "ℹ️  Lockfile changed without package.json change"; echo ""; echo "This is unusual but can be valid:"; echo "  • Security update (npm audit fix)"; echo "  • Lockfile format upgrade"; echo "  • Version resolution change"; echo ""; echo "Verify this is intentional. If not, run:"; echo "  git restore --staged package-*.json yarn.lock pnpm-lock.yaml"; echo ""; fi; fi:Check orphan lockfile change

# ------------------------------------------------------------------------------
# Python Projects
# ------------------------------------------------------------------------------

# Check if pyproject.toml changed without poetry.lock update
# pre-commit:1:false:10:if git diff --cached --name-only | grep -q "^pyproject\.toml$"; then if [ -f poetry.lock ] && ! git diff --cached --name-only | grep -q "^poetry\.lock$"; then echo ""; echo "⚠️  pyproject.toml modified but poetry.lock not updated!"; echo ""; echo "Fix: Run 'poetry lock' to update poetry.lock"; echo "Then: git add poetry.lock"; echo ""; exit 1; fi; fi:Check pyproject.toml sync

# Validate Poetry lockfile
# pre-commit:2:false:30:if [ -f poetry.lock ] && git diff --cached --name-only | grep -q "^poetry\.lock$"; then if ! poetry check --lock >/dev/null 2>&1; then echo ""; echo "❌ poetry.lock validation failed!"; echo ""; echo "Common causes:"; echo "  • poetry.lock is out of sync with pyproject.toml"; echo "  • Corrupted lockfile"; echo "  • Poetry version mismatch"; echo ""; echo "Fix: Regenerate lockfile:"; echo "  poetry lock --no-update"; echo "  git add poetry.lock"; echo ""; exit 1; fi; fi:Validate poetry.lock

# Check if Pipfile changed without Pipfile.lock update
# pre-commit:1:false:10:if git diff --cached --name-only | grep -q "^Pipfile$"; then if [ -f Pipfile.lock ] && ! git diff --cached --name-only | grep -q "^Pipfile\.lock$"; then echo ""; echo "⚠️  Pipfile modified but Pipfile.lock not updated!"; echo ""; echo "Fix: Run 'pipenv lock' to update Pipfile.lock"; echo "Then: git add Pipfile.lock"; echo ""; exit 1; fi; fi:Check Pipfile sync

# Validate Pipenv lockfile
# pre-commit:2:false:30:if [ -f Pipfile.lock ] && git diff --cached --name-only | grep -q "^Pipfile\.lock$"; then if ! pipenv verify >/dev/null 2>&1; then echo ""; echo "❌ Pipfile.lock validation failed!"; echo ""; echo "Common causes:"; echo "  • Pipfile.lock is out of sync"; echo "  • Hash mismatch"; echo "  • Corrupted lockfile"; echo ""; echo "Fix: Regenerate lockfile:"; echo "  pipenv lock"; echo "  git add Pipfile.lock"; echo ""; exit 1; fi; fi:Validate Pipfile.lock

# Detect merge conflicts in Python lockfiles
# pre-commit:1:true:5:if git diff --cached --name-only | grep -qE "poetry\.lock|Pipfile\.lock"; then if git diff --cached | grep -qE "^(<{7}|={7}|>{7})"; then echo ""; echo "❌ MERGE CONFLICT markers detected in Python lockfile!"; echo ""; echo "Fix for Poetry:"; echo "  git checkout --theirs poetry.lock  # or --ours"; echo "  poetry lock --no-update"; echo "  git add poetry.lock"; echo ""; echo "Fix for Pipenv:"; echo "  git checkout --theirs Pipfile.lock  # or --ours"; echo "  pipenv lock"; echo "  git add Pipfile.lock"; echo ""; exit 1; fi; fi:Check Python lockfile conflicts

# ------------------------------------------------------------------------------
# Go Projects
# ------------------------------------------------------------------------------

# Check if go.mod changed without go.sum update
# pre-commit:1:false:10:if git diff --cached --name-only | grep -q "^go\.mod$"; then if [ -f go.sum ] && ! git diff --cached --name-only | grep -q "^go\.sum$"; then echo ""; echo "⚠️  go.mod modified but go.sum not updated!"; echo ""; echo "Fix: Run 'go mod tidy' to update go.sum"; echo "Then: git add go.sum"; echo ""; exit 1; fi; fi:Check go.mod sync

# Validate go.sum integrity
# pre-commit:2:false:20:if [ -f go.sum ] && git diff --cached --name-only | grep -q "^go\.sum$"; then if ! go mod verify 2>/dev/null; then echo ""; echo "❌ go.sum validation failed!"; echo ""; echo "Common causes:"; echo "  • go.sum is corrupted"; echo "  • Checksum mismatch"; echo "  • Manual modification to go.sum"; echo ""; echo "Fix: Regenerate go.sum:"; echo "  rm go.sum"; echo "  go mod tidy"; echo "  git add go.sum"; echo ""; exit 1; fi; fi:Validate go.sum

# Detect merge conflicts in go.sum
# pre-commit:1:true:5:if git diff --cached --name-only | grep -q "^go\.sum$"; then if git diff --cached | grep -qE "^(<{7}|={7}|>{7})"; then echo ""; echo "❌ MERGE CONFLICT markers detected in go.sum!"; echo ""; echo "Fix:"; echo "  git checkout --theirs go.sum  # or --ours"; echo "  go mod tidy"; echo "  git add go.sum"; echo ""; exit 1; fi; fi:Check go.sum conflicts

# ------------------------------------------------------------------------------
# Rust Projects
# ------------------------------------------------------------------------------

# Check if Cargo.toml changed without Cargo.lock update
# pre-commit:1:false:10:if git diff --cached --name-only | grep -q "^Cargo\.toml$"; then if [ -f Cargo.lock ] && ! git diff --cached --name-only | grep -q "^Cargo\.lock$"; then echo ""; echo "⚠️  Cargo.toml modified but Cargo.lock not updated!"; echo ""; echo "Fix: Run 'cargo update' or 'cargo check' to update Cargo.lock"; echo "Then: git add Cargo.lock"; echo ""; exit 1; fi; fi:Check Cargo.toml sync

# Validate Cargo.lock
# pre-commit:2:false:20:if [ -f Cargo.lock ] && git diff --cached --name-only | grep -q "^Cargo\.lock$"; then if ! cargo verify-project >/dev/null 2>&1; then echo ""; echo "❌ Cargo.lock validation failed!"; echo ""; echo "Common causes:"; echo "  • Cargo.lock is out of sync"; echo "  • Corrupted lockfile"; echo "  • Version conflict"; echo ""; echo "Fix: Regenerate lockfile:"; echo "  rm Cargo.lock"; echo "  cargo check"; echo "  git add Cargo.lock"; echo ""; exit 1; fi; fi:Validate Cargo.lock

# Detect merge conflicts in Cargo.lock
# pre-commit:1:true:5:if git diff --cached --name-only | grep -q "^Cargo\.lock$"; then if git diff --cached | grep -qE "^(<{7}|={7}|>{7})"; then echo ""; echo "❌ MERGE CONFLICT markers detected in Cargo.lock!"; echo ""; echo "Fix:"; echo "  git checkout --theirs Cargo.lock  # or --ours"; echo "  cargo update"; echo "  git add Cargo.lock"; echo ""; exit 1; fi; fi:Check Cargo.lock conflicts

# ------------------------------------------------------------------------------
# Ruby Projects
# ------------------------------------------------------------------------------

# Check if Gemfile changed without Gemfile.lock update
# pre-commit:1:false:10:if git diff --cached --name-only | grep -q "^Gemfile$"; then if [ -f Gemfile.lock ] && ! git diff --cached --name-only | grep -q "^Gemfile\.lock$"; then echo ""; echo "⚠️  Gemfile modified but Gemfile.lock not updated!"; echo ""; echo "Fix: Run 'bundle install' to update Gemfile.lock"; echo "Then: git add Gemfile.lock"; echo ""; exit 1; fi; fi:Check Gemfile sync

# Validate Gemfile.lock
# pre-commit:2:false:30:if [ -f Gemfile.lock ] && git diff --cached --name-only | grep -q "^Gemfile\.lock$"; then if ! bundle check >/dev/null 2>&1; then echo ""; echo "❌ Gemfile.lock validation failed!"; echo ""; echo "Common causes:"; echo "  • Gemfile.lock is out of sync with Gemfile"; echo "  • Missing gems"; echo "  • Version conflict"; echo ""; echo "Fix: Regenerate lockfile:"; echo "  bundle install"; echo "  git add Gemfile.lock"; echo ""; exit 1; fi; fi:Validate Gemfile.lock

# Detect merge conflicts in Gemfile.lock
# pre-commit:1:true:5:if git diff --cached --name-only | grep -q "^Gemfile\.lock$"; then if git diff --cached | grep -qE "^(<{7}|={7}|>{7})"; then echo ""; echo "❌ MERGE CONFLICT markers detected in Gemfile.lock!"; echo ""; echo "Fix:"; echo "  git checkout --theirs Gemfile.lock  # or --ours"; echo "  bundle install"; echo "  git add Gemfile.lock"; echo ""; exit 1; fi; fi:Check Gemfile.lock conflicts

# ------------------------------------------------------------------------------
# PHP Projects
# ------------------------------------------------------------------------------

# Check if composer.json changed without composer.lock update
# pre-commit:1:false:10:if git diff --cached --name-only | grep -q "^composer\.json$"; then if [ -f composer.lock ] && ! git diff --cached --name-only | grep -q "^composer\.lock$"; then echo ""; echo "⚠️  composer.json modified but composer.lock not updated!"; echo ""; echo "Fix: Run 'composer update' to update composer.lock"; echo "Then: git add composer.lock"; echo ""; exit 1; fi; fi:Check composer.json sync

# Validate composer.lock
# pre-commit:2:false:30:if [ -f composer.lock ] && git diff --cached --name-only | grep -q "^composer\.lock$"; then if ! composer validate --no-check-all >/dev/null 2>&1; then echo ""; echo "❌ composer.lock validation failed!"; echo ""; echo "Common causes:"; echo "  • composer.lock is out of sync"; echo "  • Invalid JSON format"; echo "  • Version mismatch"; echo ""; echo "Fix: Regenerate lockfile:"; echo "  composer update --lock"; echo "  git add composer.lock"; echo ""; exit 1; fi; fi:Validate composer.lock

# Detect merge conflicts in composer.lock
# pre-commit:1:true:5:if git diff --cached --name-only | grep -q "^composer\.lock$"; then if git diff --cached | grep -qE "^(<{7}|={7}|>{7})"; then echo ""; echo "❌ MERGE CONFLICT markers detected in composer.lock!"; echo ""; echo "Fix:"; echo "  git checkout --theirs composer.lock  # or --ours"; echo "  composer update --lock"; echo "  git add composer.lock"; echo ""; exit 1; fi; fi:Check composer.lock conflicts

# ------------------------------------------------------------------------------
# Swift / iOS Projects
# ------------------------------------------------------------------------------

# Check if Package.swift changed without Package.resolved update
# pre-commit:1:false:10:if git diff --cached --name-only | grep -q "^Package\.swift$"; then if [ -f Package.resolved ] && ! git diff --cached --name-only | grep -q "^Package\.resolved$"; then echo ""; echo "⚠️  Package.swift modified but Package.resolved not updated!"; echo ""; echo "Fix: Run 'swift package resolve' to update Package.resolved"; echo "Then: git add Package.resolved"; echo ""; exit 1; fi; fi:Check Package.swift sync

# Check if Podfile changed without Podfile.lock update (CocoaPods)
# pre-commit:1:false:10:if git diff --cached --name-only | grep -q "^Podfile$"; then if [ -f Podfile.lock ] && ! git diff --cached --name-only | grep -q "^Podfile\.lock$"; then echo ""; echo "⚠️  Podfile modified but Podfile.lock not updated!"; echo ""; echo "Fix: Run 'pod install' to update Podfile.lock"; echo "Then: git add Podfile.lock"; echo ""; exit 1; fi; fi:Check Podfile sync

# ------------------------------------------------------------------------------
# Terraform / Infrastructure
# ------------------------------------------------------------------------------

# Check if Terraform files changed without .terraform.lock.hcl update
# pre-commit:1:false:10:if git diff --cached --name-only | grep -q "\.tf$"; then if [ -f .terraform.lock.hcl ] && ! git diff --cached --name-only | grep -q "\.terraform\.lock\.hcl$"; then echo ""; echo "ℹ️  Terraform files changed - verify provider lock file"; echo ""; echo "If providers changed, update lock:"; echo "  terraform init -upgrade"; echo "  git add .terraform.lock.hcl"; echo ""; echo "If providers didn't change, this is OK."; echo ""; fi; fi:Check Terraform lock sync

# Validate Terraform lock file
# pre-commit:2:false:30:if [ -f .terraform.lock.hcl ] && git diff --cached --name-only | grep -q "\.terraform\.lock\.hcl$"; then if ! terraform validate -no-color >/dev/null 2>&1; then echo ""; echo "❌ Terraform validation failed!"; echo ""; echo "Common causes:"; echo "  • .terraform.lock.hcl is corrupted"; echo "  • Provider version conflict"; echo "  • Terraform configuration error"; echo ""; echo "Fix: Regenerate lock file:"; echo "  rm .terraform.lock.hcl"; echo "  terraform init"; echo "  git add .terraform.lock.hcl"; echo ""; exit 1; fi; fi:Validate Terraform lock

# ------------------------------------------------------------------------------
# Monorepo / Workspace Projects
# ------------------------------------------------------------------------------

# Check workspace package.json changes in monorepo
# pre-commit:1:false:15:if [ -f package.json ] && grep -q "workspaces" package.json 2>/dev/null; then if git diff --cached --name-only | grep -qE "packages/.*/package\.json|apps/.*/package\.json"; then if [ -f package-lock.json ] && ! git diff --cached --name-only | grep -q "package-lock\.json"; then echo ""; echo "⚠️  Workspace package.json changed but root package-lock.json not updated!"; echo ""; echo "Fix: Run from workspace root:"; echo "  npm install"; echo "  git add package-lock.json"; echo ""; exit 1; elif [ -f yarn.lock ] && ! git diff --cached --name-only | grep -q "yarn\.lock"; then echo ""; echo "⚠️  Workspace package.json changed but root yarn.lock not updated!"; echo ""; echo "Fix: Run from workspace root:"; echo "  yarn install"; echo "  git add yarn.lock"; echo ""; exit 1; elif [ -f pnpm-lock.yaml ] && ! git diff --cached --name-only | grep -q "pnpm-lock\.yaml"; then echo ""; echo "⚠️  Workspace package.json changed but root pnpm-lock.yaml not updated!"; echo ""; echo "Fix: Run from workspace root:"; echo "  pnpm install"; echo "  git add pnpm-lock.yaml"; echo ""; exit 1; fi; fi; fi:Check monorepo workspace sync

# ------------------------------------------------------------------------------
# Universal Lockfile Checks
# ------------------------------------------------------------------------------

# Prevent accidentally committing node_modules or vendor directories
# pre-commit:1:true:5:if git diff --cached --name-only | grep -qE "node_modules/|vendor/bundle/|\.venv/|venv/|__pycache__/"; then echo ""; echo "❌ BLOCKED: Attempting to commit dependency directory!"; echo ""; echo "Detected:"; git diff --cached --name-only | grep -E "node_modules/|vendor/bundle/|\.venv/|venv/|__pycache__/" | head -5; echo ""; echo "These should be in .gitignore, not committed!"; echo ""; echo "Fix:"; echo "  git restore --staged node_modules/ vendor/ .venv/ venv/ __pycache__/"; echo "  echo 'node_modules/' >> .gitignore  # (or appropriate directory)"; echo "  git add .gitignore"; echo ""; exit 1; fi:Block dependency directories

# ==============================================================================
# USAGE INSTRUCTIONS FOR LOCKFILE VALIDATION
# ==============================================================================
#
# To enable lockfile validation for your project:
#
# 1. Uncomment the relevant sections above for your technology stack
# 2. Start with mandatory=false (warnings only) for 1-2 weeks
# 3. Monitor team feedback and adjust as needed
# 4. Change to mandatory=true once team is comfortable
#
# Example for Node.js project:
#   Uncomment lines in "Node.js / JavaScript / TypeScript Projects" section
#
# Example for Python project:
#   Uncomment lines in "Python Projects" section
#
# Example for multi-language project:
#   Uncomment multiple sections as needed
#
# Tips:
#   • Keep checks fast (<30s total)
#   • Provide clear, actionable error messages
#   • Test commands locally before enabling
#   • Use mandatory=false initially
#   • Document in your team's onboarding guide
#
# ==============================================================================

# ==============================================================================
# Notes
# ==============================================================================
# 
# Priority Guidelines:
#   1-10    : Critical, fast checks (format, lint, lockfile sync)
#   11-20   : Important checks (type check, compilation)
#   21-30   : Optional quality checks
#   31+     : Slow, optional validations
#
# Timeout Guidelines:
#   5-10s   : Fast checks (conflict detection, file presence)
#   10-30s  : Format checkers, linters, basic lockfile validation
#   30-90s  : Type checkers, compilation, deep lockfile validation
#   90-300s : Unit tests
#   300-600s: Integration tests, builds
#
# Mandatory Guidelines:
#   true    : Must pass for commit/push to succeed
#   false   : Warning only, doesn't block (recommended for rollout)
#
# Lockfile Validation Priority Recommendations:
#   Priority 1: Merge conflict detection (mandatory=true, timeout=5s)
#   Priority 1: Manifest-lockfile sync check (mandatory=false, timeout=10s)
#   Priority 2: Lockfile integrity validation (mandatory=false, timeout=20-30s)
#   Priority 3: Orphan lockfile change warning (mandatory=false, timeout=10s)
#
# ==============================================================================
