#!/usr/bin/env bash
# ==============================================================================
# Git Hook: prepare-commit-msg
# ==============================================================================
# Auto-populates commit messages with JIRA ID extracted from branch name.
# Runs before commit-msg hook and pre-fills the commit message template.
#
# Features:
# - Extracts JIRA ID from branch name
# - Pre-fills commit message with proper format
# - Skips for merge commits, amend, and already formatted messages
# - Preserves existing commit messages
#
# Environment Variables:
# - BYPASS_HOOKS=1: Skip hook execution
#
# Author: Enterprise Development Team
# ==============================================================================

set -euo pipefail

# Source common library
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
# shellcheck source=lib/common.sh
source "${SCRIPT_DIR}/lib/common.sh"

readonly HOOK_NAME="prepare-commit-msg"

# ==============================================================================
# MAIN HOOK LOGIC
# ==============================================================================

main() {
    local commit_msg_file="$1"
    local commit_source="${2:-}"
    local commit_sha="${3:-}"
    
    # Display strong warning if bypass mechanisms are active (BEFORE any logic)
    warn_if_bypass_active "$HOOK_NAME"
    
    log_to_file "INFO" "$HOOK_NAME" "Hook execution started (source: ${commit_source:-manual})"
    
    # Check for global bypass
    if should_bypass_hooks; then
        log_bypass "$HOOK_NAME" "Hook bypassed via BYPASS_HOOKS"
        exit 0
    fi
    
    # Skip for certain commit sources
    case "$commit_source" in
        merge|squash|commit)
            log_to_file "INFO" "$HOOK_NAME" "Skipping for commit source: $commit_source"
            exit 0
            ;;
    esac
    
    # Get current branch
    local current_branch
    current_branch=$(get_current_branch)
    
    if [[ "$current_branch" == "DETACHED" ]]; then
        log_to_file "INFO" "$HOOK_NAME" "Detached HEAD state, skipping"
        exit 0
    fi
    
    # Extract JIRA ID from branch name
    local jira_id
    if ! jira_id=$(extract_jira_id "$current_branch"); then
        log_to_file "INFO" "$HOOK_NAME" "No JIRA ID found in branch: $current_branch"
        exit 0
    fi
    
    log_to_file "INFO" "$HOOK_NAME" "Extracted JIRA ID: $jira_id from branch: $current_branch"
    
    # Read current commit message
    local current_msg
    current_msg=$(cat "$commit_msg_file")
    
    # Skip if message already contains JIRA ID
    if [[ "$current_msg" =~ $jira_id ]]; then
        log_to_file "INFO" "$HOOK_NAME" "JIRA ID already present in commit message"
        exit 0
    fi
    
    # Skip if message already follows format
    if [[ "$current_msg" =~ ^(feat|fix|chore|break|tests): ]]; then
        log_to_file "INFO" "$HOOK_NAME" "Commit message already formatted"
        exit 0
    fi
    
    # Determine commit type based on branch type
    local branch_type
    branch_type=$(get_branch_type "$current_branch")
    
    local commit_prefix="feat"
    case "$branch_type" in
        bugfix|hotfix)
            commit_prefix="fix"
            ;;
        feature)
            commit_prefix="feat"
            ;;
        support)
            # Try to detect from branch name prefix
            if [[ "$current_branch" =~ ^(chore|docs|style|refactor|perf|test|ci|build) ]]; then
                commit_prefix="${BASH_REMATCH[1]}"
            else
                commit_prefix="chore"
            fi
            ;;
    esac
    
    # Prepare new commit message
    local new_msg
    if [[ -z "$current_msg" ]] || [[ "$current_msg" =~ ^#.*$ ]]; then
        # Empty or only comments - create template
        new_msg="${commit_prefix}: ${jira_id} "
        new_msg+=$'\n\n'
        new_msg+="# Please enter a descriptive commit message above"$'\n'
        new_msg+="# Format: <type>: <JIRA-ID> <description>"$'\n'
        new_msg+="#"$'\n'
        new_msg+="# Types: feat, fix, chore, break, tests"$'\n'
        new_msg+="# Example: feat: ${jira_id} Add user authentication"$'\n'
        new_msg+="#"$'\n'
        new_msg+="# Your branch: ${current_branch}"$'\n'
    else
        # Preserve existing message and prepend format
        new_msg="${commit_prefix}: ${jira_id} ${current_msg}"
    fi
    
    # Write new message
    echo "$new_msg" > "$commit_msg_file"
    
    log_to_file "INFO" "$HOOK_NAME" "Commit message prepared with JIRA ID: $jira_id"
    
    exit 0
}

# Execute main function
main "$@"
